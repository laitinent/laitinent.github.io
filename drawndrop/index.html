<!DOCTYPE html>
<html lang="fi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>P2.js Piirtosimulaattori</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- p2.js Physics Engine (0.7.1) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p2.js/0.7.1/p2.min.js"></script>
    <!-- Poly-decomp kirjasto muotojen pilkkomiseen -->
    <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #0f172a;
        user-select: none; /* Estä tekstin valinta piirtäessä */
        overflow: hidden; /* Estä sivu-scrollaus */
      }
      canvas {
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        background-color: #2c3e50;
        touch-action: none;
        cursor: crosshair;
      }
    </style>
  </head>
  <body class="p-4 flex flex-col items-center justify-center min-h-screen">
    <div class="text-white text-center mb-4 z-10">
      <h1 class="text-3xl font-bold mb-1">Piirrä ja Kasaa</h1>
      <p class="text-gray-400 text-sm">
        Nyt voit piirtää myös koveria muotoja (esim. kupin)!
      </p>
    </div>

    <div class="relative w-full max-w-lg aspect-square">
      <canvas id="physicsCanvas" class="w-full h-full block"></canvas>

      <!-- Reset-nappi -->
      <button
        id="resetButton"
        class="absolute top-4 right-4 bg-red-600/80 hover:bg-red-600 text-white p-2 rounded-lg shadow-lg transition backdrop-blur-sm"
        title="Tyhjennä kenttä"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          class="h-6 w-6"
          fill="none"
          viewBox="0 0 24 24"
          stroke="currentColor"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
          />
        </svg>
      </button>
    </div>

    <script>
      // --- Globaalit muuttujat ---
      let canvas, ctx, world;
      let groundBody,
        dynamicBodies = [];

      let isDrawing = false;
      let drawPath = [];

      // --- Äänimanageri ---
      const SoundManager = {
        ctx: null,
        init: function () {
          if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (this.ctx.state === "suspended") {
            this.ctx.resume();
          }
        },
        playTone: function (freq, type, duration, vol = 0.1) {
          if (!this.ctx) return;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
          gain.gain.setValueAtTime(vol, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.01,
            this.ctx.currentTime + duration
          );
          osc.connect(gain);
          gain.connect(this.ctx.destination);
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
        },
        playDrawComplete: function () {
          // Iloinen "ding" (C5 -> E5)
          this.init();
          const now = this.ctx.currentTime;
          this.playTone(523.25, "sine", 0.3, 0.1);
          setTimeout(() => {
            if (this.ctx) {
              const osc = this.ctx.createOscillator();
              const gain = this.ctx.createGain();
              osc.type = "sine";
              osc.frequency.setValueAtTime(659.25, this.ctx.currentTime);
              gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
              gain.gain.exponentialRampToValueAtTime(
                0.01,
                this.ctx.currentTime + 0.3
              );
              osc.connect(gain);
              gain.connect(this.ctx.destination);
              osc.start();
              osc.stop(this.ctx.currentTime + 0.4);
            }
          }, 100);
        },
        playCollision: function (intensity) {
          this.init();
          // Matala "tömähdys"
          // Intensity on n. 0-20+, skaalataan se järkeväksi
          const vol = Math.min(Math.max(intensity * 0.05, 0.01), 0.3);
          if (vol < 0.02) return; // Ei ääntä hyvin pienistä osumista

          // Satunnaistetaan hieman taajuutta, jotta kuulostaa orgaanisemmalta
          const freq = 60 + Math.random() * 40;
          this.playTone(freq, "triangle", 0.1 + vol * 0.2, vol);
        },
      };

      const PTM_RATIO = 50;
      const CANVAS_SIZE_M = 10;

      // --- Apuohjelmat ---

      function mToPx(m) {
        return m * PTM_RATIO;
      }
      function pxToM(px) {
        return px / PTM_RATIO;
      }
      function canvasYToWorldY(y) {
        return (canvas.height - y) / PTM_RATIO;
      }

      // --- Convex Hull Fallback ---
      function crossProduct(o, a, b) {
        return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
      }

      function getConvexHull(points) {
        if (points.length <= 2) return points;
        const sorted = points
          .slice()
          .sort((a, b) => (a.x === b.x ? a.y - b.y : a.x - b.x));
        const lower = [];
        for (let p of sorted) {
          while (
            lower.length >= 2 &&
            crossProduct(lower[lower.length - 2], lower[lower.length - 1], p) <=
              0
          ) {
            lower.pop();
          }
          lower.push(p);
        }
        const upper = [];
        for (let i = sorted.length - 1; i >= 0; i--) {
          const p = sorted[i];
          while (
            upper.length >= 2 &&
            crossProduct(upper[upper.length - 2], upper[upper.length - 1], p) <=
              0
          ) {
            upper.pop();
          }
          upper.push(p);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
      }

      // --- Alustus ---

      function initCanvas() {
        canvas = document.getElementById("physicsCanvas");
        ctx = canvas.getContext("2d");
        updateCanvasSize();
      }

      function updateCanvasSize() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        if (world && groundBody) {
          groundBody.position = [pxToM(canvas.width) / 2, 0];
        }
      }

      function initPhysicsWorld() {
        world = new p2.World({
          gravity: [0, -9.82],
        });
        world.solver.iterations = 20;
        world.solver.tolerance = 0.001;

        // Lattia
        groundBody = new p2.Body({
          mass: 0,
          position: [CANVAS_SIZE_M / 2, 0],
        });
        const groundShape = new p2.Box({ width: 100, height: 1 });
        groundShape.material = new p2.Material();
        groundBody.addShape(groundShape);
        world.addBody(groundBody);

        world.sleepMode = p2.World.BODY_SLEEPING;
        dynamicBodies = [];
        createContactMaterials(groundShape.material);

        world.on("impact", function (evt) {
          const bodyA = evt.bodyA;
          const bodyB = evt.bodyB;

          // Ohitetaan osumat, jos kumpikaan ei ole dynaaminen (esim. lattia vs staattinen)
          // Mutta tässä simulaatiossa lattia on staattinen ja piirretyt dynaamisia.
          // Haluamme äänen kun dynaaminen osuu mihin tahansa.

          // Tarkistetaan iskun voimakkuus
          // getVelocityAlongNormal() vaatii kontaktiequationin, mutta impact-eventissä
          // p2.js 0.7.1 ei välttämättä tarjoa sitä suoraan samalla tavalla kaikissa buildessa.
          // Käytetään yksinkertaista suhteellista nopeutta jos mahdollista.

          // Varmempi tapa p2.js:ssä:
          if (evt.contactEquation) {
            const v = Math.abs(evt.contactEquation.getVelocityAlongNormal());
            SoundManager.playCollision(v);
          }
        });
      }

      function createContactMaterials(groundMat) {
        const shapeMaterial = new p2.Material();
        window.defaultShapeMaterial = shapeMaterial;

        const contactMaterial = new p2.ContactMaterial(
          groundMat,
          shapeMaterial,
          {
            restitution: 0.1,
            friction: 1.5,
            frictionStiffness: 1e7,
            frictionRelaxation: 3,
          }
        );

        const shapeContactMaterial = new p2.ContactMaterial(
          shapeMaterial,
          shapeMaterial,
          {
            restitution: 0.1,
            friction: 1.5,
          }
        );

        world.addContactMaterial(contactMaterial);
        world.addContactMaterial(shapeContactMaterial);
      }

      // --- Kappaleen luonti ---

      function createBodyFromPath(path) {
        if (path.length < 3) return;

        // 1. Yksinkertaistus
        const simplifiedPath = [];
        simplifiedPath.push(path[0]);
        for (let i = 1; i < path.length; i++) {
          const last = simplifiedPath[simplifiedPath.length - 1];
          const curr = path[i];
          if (Math.hypot(curr.x - last.x, curr.y - last.y) > 10) {
            // Tarkempi (10px) parempaa tulosta varten
            simplifiedPath.push(curr);
          }
        }
        if (simplifiedPath.length < 3) return;

        // 2. Laske keskipiste (Centroid)
        let cx = 0,
          cy = 0;
        for (let p of simplifiedPath) {
          cx += p.x;
          cy += p.y;
        }
        cx /= simplifiedPath.length;
        cy /= simplifiedPath.length;

        // 3. Luo verteksit suhteessa keskipisteeseen
        const pathVertices = simplifiedPath.map((p) => {
          return [
            pxToM(p.x - cx),
            pxToM(-(p.y - cy)), // Y-käännös
          ];
        });

        // 4. Luo kappale
        const body = new p2.Body({
          mass: 1,
          position: [pxToM(cx), canvasYToWorldY(cy)],
        });

        // 5. Yritä pilkkoa muoto
        let success = false;
        try {
          // p2.Body.fromPolygon onnistuu vain jos poly-decomp on ladattu oikein
          success = body.fromPolygon(pathVertices);

          if (success) {
            body.shapes.forEach((shape) => {
              shape.material = window.defaultShapeMaterial;
            });
          }
        } catch (e) {
          console.warn("Decomposition virhe:", e);
          success = false;
        }

        // 6. Fallback (Convex Hull) jos pilkkominen epäonnistui
        if (!success) {
          body.shapes = []; // Tyhjennä roskat

          const hullPoints = getConvexHull(simplifiedPath);

          let hcx = 0,
            hcy = 0;
          for (let p of hullPoints) {
            hcx += p.x;
            hcy += p.y;
          }
          hcx /= hullPoints.length;
          hcy /= hullPoints.length;

          // Päivitä body vastaamaan uutta keskipistettä
          body.position = [pxToM(hcx), canvasYToWorldY(hcy)];

          const cleanHullVerts = hullPoints.map((p) => [
            pxToM(p.x - hcx),
            pxToM(-(p.y - hcy)),
          ]);

          // Tarkista suunta (CCW)
          let area = 0;
          for (let i = 0; i < cleanHullVerts.length; i++) {
            const j = (i + 1) % cleanHullVerts.length;
            area += cleanHullVerts[i][0] * cleanHullVerts[j][1];
            area -= cleanHullVerts[j][0] * cleanHullVerts[i][1];
          }
          if (area < 0) cleanHullVerts.reverse();

          const convexShape = new p2.Convex({ vertices: cleanHullVerts });
          convexShape.material = window.defaultShapeMaterial;
          body.addShape(convexShape);
        }

        world.addBody(body);
        dynamicBodies.push(body);
      }

      // --- Renderöinti ---

      function drawShape(shape, body) {
        ctx.save();
        // 1. Siirry kappaleen keskipisteeseen
        ctx.translate(mToPx(body.position[0]), mToPx(body.position[1]));
        ctx.rotate(body.angle);

        ctx.lineWidth = 2;

        if (shape instanceof p2.Box) {
          const w = mToPx(shape.width);
          const h = mToPx(shape.height);
          ctx.fillStyle = "#1e293b";
          ctx.fillRect(-w / 2, -h / 2, w, h);
          ctx.beginPath();
          ctx.moveTo(-w / 2, h / 2);
          ctx.lineTo(w / 2, h / 2);
          ctx.strokeStyle = "#3b82f6";
          ctx.stroke();
        } else if (shape instanceof p2.Convex) {
          // TÄRKEÄ KORJAUS:
          // Kun muoto on pilkottu (decomp), osilla on omat suhteelliset sijainnit (position) ja kulmat (angle).
          // Meidän täytyy siirtää piirtoa näiden mukaan suhteessa bodyn keskipisteeseen.
          ctx.save();
          if (shape.position) {
            ctx.translate(mToPx(shape.position[0]), mToPx(shape.position[1]));
          }
          if (shape.angle) {
            ctx.rotate(shape.angle);
          }

          const verts = shape.vertices;
          ctx.beginPath();
          if (verts.length > 0) {
            ctx.moveTo(mToPx(verts[0][0]), mToPx(verts[0][1]));
            for (let i = 1; i < verts.length; i++) {
              ctx.lineTo(mToPx(verts[i][0]), mToPx(verts[i][1]));
            }
          }
          ctx.closePath();
          ctx.fillStyle = "#facc15";
          ctx.strokeStyle = "#a16207";
          ctx.fill();
          ctx.stroke();

          ctx.restore(); // Palauta shape-kohtainen siirros
        }

        ctx.restore(); // Palauta body-kohtainen siirros
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);

        world.bodies.forEach((body) => {
          body.shapes.forEach((shape) => drawShape(shape, body));
        });
        ctx.restore();

        if (isDrawing && drawPath.length > 0) {
          ctx.lineCap = "round";
          ctx.lineJoin = "round";

          ctx.beginPath();
          ctx.moveTo(drawPath[0].x, drawPath[0].y);
          for (let i = 1; i < drawPath.length; i++)
            ctx.lineTo(drawPath[i].x, drawPath[i].y);
          ctx.strokeStyle = "#ef4444";
          ctx.lineWidth = 4;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(drawPath[0].x, drawPath[0].y);
          for (let i = 1; i < drawPath.length; i++)
            ctx.lineTo(drawPath[i].x, drawPath[i].y);
          ctx.closePath();
          ctx.fillStyle = "rgba(250, 204, 21, 0.2)";
          ctx.fill();
        }
      }

      let lastTime = 0;
      const timeStep = 1 / 60;

      function animate(time) {
        requestAnimationFrame(animate);
        const deltaTime = (time - lastTime) / 1000;
        lastTime = time;
        world.step(timeStep, deltaTime, 10);
        render();
      }

      // --- POINTER EVENTS ---

      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }

      function handlePointerDown(e) {
        if (e.target !== canvas) return;
        e.preventDefault();
        isDrawing = true;
        drawPath = [getPos(e)];
        canvas.setPointerCapture(e.pointerId);
        SoundManager.init(); // Käynnistä AudioContext user gesturella
      }

      function handlePointerMove(e) {
        if (!isDrawing) return;
        e.preventDefault();
        const pos = getPos(e);
        const last = drawPath[drawPath.length - 1];
        if (Math.hypot(pos.x - last.x, pos.y - last.y) > 2) {
          drawPath.push(pos);
        }
      }

      function handlePointerUp(e) {
        if (!isDrawing) return;
        isDrawing = false;
        canvas.releasePointerCapture(e.pointerId);
        createBodyFromPath(drawPath);
        drawPath = [];
        SoundManager.playDrawComplete();
      }

      function resetSimulation() {
        dynamicBodies.forEach((b) => world.removeBody(b));
        dynamicBodies = [];
      }

      window.onload = function () {
        initCanvas();
        initPhysicsWorld();

        canvas.addEventListener("pointerdown", handlePointerDown);
        canvas.addEventListener("pointermove", handlePointerMove);
        canvas.addEventListener("pointerup", handlePointerUp);
        canvas.addEventListener("pointercancel", handlePointerUp);

        document
          .getElementById("resetButton")
          .addEventListener("click", resetSimulation);
        window.addEventListener("resize", updateCanvasSize);

        requestAnimationFrame(animate);
      };
    </script>
  </body>
</html>
