<!DOCTYPE html>
<html lang="fi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>P2.js Piirtosimulaattori</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- p2.js Physics Engine (0.7.1) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p2.js/0.7.1/p2.min.js"></script>
    <!-- Poly-decomp kirjasto muotojen pilkkomiseen -->
    <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #0f172a;
        user-select: none; /* Estä tekstin valinta piirtäessä */
        overflow: hidden; /* Estä sivu-scrollaus */
      }
      canvas {
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        background-color: #2c3e50;
        touch-action: none;
        cursor: crosshair;
      }
    </style>
  </head>
  <body class="p-4 flex flex-col items-center justify-center min-h-screen">
    <div class="fixed top-4 left-4 text-white z-10 pointer-events-none">
      <h1 class="text-2xl font-bold mb-1 opacity-80">Piirrä ja Kasaa</h1>
    </div>

    <!-- Canvas container changes for fullscreen with margins -->
    <div class="relative w-[calc(100vw-2rem)] h-[calc(100vh-2rem)] m-4">
      <canvas id="physicsCanvas" class="w-full h-full block"></canvas>

      <!-- Kontrollit -->
      <!-- Kontrollit -->
      <div class="absolute top-4 right-4 flex gap-2">
        <!-- Gravity-nappi -->
        <button
          id="gravityButton"
          class="bg-slate-600/80 hover:bg-slate-600 text-white p-2 rounded-lg shadow-lg transition backdrop-blur-sm"
          title="Ota kallistusohjaus käyttöön"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-6 w-6"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2z"
            />
          </svg>
        </button>

        <!-- Mute-nappi -->
        <button
          id="muteButton"
          class="bg-slate-600/80 hover:bg-slate-600 text-white p-2 rounded-lg shadow-lg transition backdrop-blur-sm"
          title="Mykistä äänet"
        >
          <!-- Speaker Wave Icon (Sound On) -->
          <svg
            id="iconSoundOn"
            xmlns="http://www.w3.org/2000/svg"
            class="h-6 w-6"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"
            />
          </svg>
          <!-- Speaker X Icon (Sound Off) - Hidden by default -->
          <svg
            id="iconSoundOff"
            xmlns="http://www.w3.org/2000/svg"
            class="h-6 w-6 hidden"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15zM17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2"
            />
          </svg>
        </button>

        <!-- Reset-nappi -->
        <button
          id="resetButton"
          class="bg-red-600/80 hover:bg-red-600 text-white p-2 rounded-lg shadow-lg transition backdrop-blur-sm"
          title="Tyhjennä kenttä"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-6 w-6"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
            />
          </svg>
        </button>
      </div>
    </div>

    <script>
      // --- Globaalit muuttujat ---
      let canvas, ctx, world;
      let groundBody,
        dynamicBodies = [];

      let isDrawing = false;

      let drawPath = [];

      let gravityEnabled = false;
      const MAX_GRAVITY = 20;

      // --- Äänimanageri ---
      const SoundManager = {
        ctx: null,
        muted: false,
        init: function () {
          if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (this.ctx.state === "suspended") {
            this.ctx.resume();
          }
        },
        toggleMute: function () {
          this.muted = !this.muted;
          return this.muted;
        },
        playTone: function (freq, type, duration, vol = 0.1) {
          if (!this.ctx || this.muted) return;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
          gain.gain.setValueAtTime(vol, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.01,
            this.ctx.currentTime + duration
          );
          osc.connect(gain);
          gain.connect(this.ctx.destination);
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
        },
        playDrawComplete: function () {
          // Iloinen "ding" (C5 -> E5)
          this.init();
          const now = this.ctx.currentTime;
          this.playTone(523.25, "sine", 0.3, 0.1);
          setTimeout(() => {
            if (this.ctx) {
              const osc = this.ctx.createOscillator();
              const gain = this.ctx.createGain();
              osc.type = "sine";
              osc.frequency.setValueAtTime(659.25, this.ctx.currentTime);
              gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
              gain.gain.exponentialRampToValueAtTime(
                0.01,
                this.ctx.currentTime + 0.3
              );
              osc.connect(gain);
              gain.connect(this.ctx.destination);
              osc.start();
              osc.stop(this.ctx.currentTime + 0.4);
            }
          }, 100);
        },
        playCollision: function (intensity) {
          this.init();
          // Matala "tömähdys"
          // Intensity on n. 0-20+, skaalataan se järkeväksi
          const vol = Math.min(Math.max(intensity * 0.05, 0.01), 0.3);
          if (vol < 0.02) return; // Ei ääntä hyvin pienistä osumista

          // Satunnaistetaan hieman taajuutta, jotta kuulostaa orgaanisemmalta
          const freq = 60 + Math.random() * 40;
          this.playTone(freq, "triangle", 0.1 + vol * 0.2, vol);
        },
      };

      const PTM_RATIO = 50;
      const CANVAS_SIZE_M = 10;

      // --- Apuohjelmat ---

      function mToPx(m) {
        return m * PTM_RATIO;
      }
      function pxToM(px) {
        return px / PTM_RATIO;
      }
      function canvasYToWorldY(y) {
        return (canvas.height - y) / PTM_RATIO;
      }

      // --- Convex Hull Fallback ---
      function crossProduct(o, a, b) {
        return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
      }

      function getConvexHull(points) {
        if (points.length <= 2) return points;
        const sorted = points
          .slice()
          .sort((a, b) => (a.x === b.x ? a.y - b.y : a.x - b.x));
        const lower = [];
        for (let p of sorted) {
          while (
            lower.length >= 2 &&
            crossProduct(lower[lower.length - 2], lower[lower.length - 1], p) <=
              0
          ) {
            lower.pop();
          }
          lower.push(p);
        }
        const upper = [];
        for (let i = sorted.length - 1; i >= 0; i--) {
          const p = sorted[i];
          while (
            upper.length >= 2 &&
            crossProduct(upper[upper.length - 2], upper[upper.length - 1], p) <=
              0
          ) {
            upper.pop();
          }
          upper.push(p);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
      }

      // --- Alustus ---

      function initCanvas() {
        canvas = document.getElementById("physicsCanvas");
        ctx = canvas.getContext("2d");
        updateCanvasSize();
      }

      function updateCanvasSize() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;

        // Päivitä lattian sijainti ja koko vastaamaan uutta canvasia
        if (world && groundBody) {
          const groundY = 0; // Lattia on aina y=0 (maailmakoordinaateissa)
          // Lattian keskipiste X-suunnassa
          groundBody.position = [pxToM(canvas.width) / 2, groundY];

          // Päivitä lattian muodon koko kattamaan koko uusi leveys
          if (groundBody.shapes.length > 0) {
            groundBody.shapes[0].width = pxToM(canvas.width) + 100; // Extra leveyttä varmuuden vuoksi
          }
        }
      }

      function initPhysicsWorld() {
        world = new p2.World({
          gravity: [0, -9.82],
        });
        world.solver.iterations = 20;
        world.solver.tolerance = 0.001;

        // Lattia
        groundBody = new p2.Body({
          mass: 0,
          position: [CANVAS_SIZE_M / 2, 0],
        });
        const groundShape = new p2.Box({ width: 100, height: 1 });
        groundShape.material = new p2.Material();
        groundBody.addShape(groundShape);
        world.addBody(groundBody);

        world.sleepMode = p2.World.BODY_SLEEPING;
        dynamicBodies = [];
        createContactMaterials(groundShape.material);

        world.on("impact", function (evt) {
          const bodyA = evt.bodyA;
          const bodyB = evt.bodyB;

          // Ohitetaan osumat, jos kumpikaan ei ole dynaaminen (esim. lattia vs staattinen)
          // Mutta tässä simulaatiossa lattia on staattinen ja piirretyt dynaamisia.
          // Haluamme äänen kun dynaaminen osuu mihin tahansa.

          // Tarkistetaan iskun voimakkuus
          // getVelocityAlongNormal() vaatii kontaktiequationin, mutta impact-eventissä
          // p2.js 0.7.1 ei välttämättä tarjoa sitä suoraan samalla tavalla kaikissa buildessa.
          // Käytetään yksinkertaista suhteellista nopeutta jos mahdollista.

          // Varmempi tapa p2.js:ssä:
          if (evt.contactEquation) {
            const v = Math.abs(evt.contactEquation.getVelocityAlongNormal());
            SoundManager.playCollision(v);
          }
        });
      }

      function createContactMaterials(groundMat) {
        const shapeMaterial = new p2.Material();
        window.defaultShapeMaterial = shapeMaterial;

        const contactMaterial = new p2.ContactMaterial(
          groundMat,
          shapeMaterial,
          {
            restitution: 0.1,
            friction: 1.5,
            frictionStiffness: 1e7,
            frictionRelaxation: 3,
          }
        );

        const shapeContactMaterial = new p2.ContactMaterial(
          shapeMaterial,
          shapeMaterial,
          {
            restitution: 0.1,
            friction: 1.5,
          }
        );

        world.addContactMaterial(contactMaterial);
        world.addContactMaterial(shapeContactMaterial);
      }

      // --- Kappaleen luonti ---

      function createBodyFromPath(path) {
        if (path.length < 3) return;

        // 1. Yksinkertaistus
        const simplifiedPath = [];
        simplifiedPath.push(path[0]);
        for (let i = 1; i < path.length; i++) {
          const last = simplifiedPath[simplifiedPath.length - 1];
          const curr = path[i];
          if (Math.hypot(curr.x - last.x, curr.y - last.y) > 10) {
            // Tarkempi (10px) parempaa tulosta varten
            simplifiedPath.push(curr);
          }
        }
        if (simplifiedPath.length < 3) return;

        // 2. Laske keskipiste (Centroid)
        let cx = 0,
          cy = 0;
        for (let p of simplifiedPath) {
          cx += p.x;
          cy += p.y;
        }
        cx /= simplifiedPath.length;
        cy /= simplifiedPath.length;

        // 3. Luo verteksit suhteessa keskipisteeseen
        const pathVertices = simplifiedPath.map((p) => {
          return [
            pxToM(p.x - cx),
            pxToM(-(p.y - cy)), // Y-käännös
          ];
        });

        // 4. Luo kappale
        const body = new p2.Body({
          mass: 1,
          position: [pxToM(cx), canvasYToWorldY(cy)],
        });

        // 5. Yritä pilkkoa muoto
        let success = false;
        try {
          // p2.Body.fromPolygon onnistuu vain jos poly-decomp on ladattu oikein
          success = body.fromPolygon(pathVertices);

          if (success) {
            body.shapes.forEach((shape) => {
              shape.material = window.defaultShapeMaterial;
            });
          }
        } catch (e) {
          console.warn("Decomposition virhe:", e);
          success = false;
        }

        // 6. Fallback (Convex Hull) jos pilkkominen epäonnistui
        if (!success) {
          body.shapes = []; // Tyhjennä roskat

          const hullPoints = getConvexHull(simplifiedPath);

          let hcx = 0,
            hcy = 0;
          for (let p of hullPoints) {
            hcx += p.x;
            hcy += p.y;
          }
          hcx /= hullPoints.length;
          hcy /= hullPoints.length;

          // Päivitä body vastaamaan uutta keskipistettä
          body.position = [pxToM(hcx), canvasYToWorldY(hcy)];

          const cleanHullVerts = hullPoints.map((p) => [
            pxToM(p.x - hcx),
            pxToM(-(p.y - hcy)),
          ]);

          // Tarkista suunta (CCW)
          let area = 0;
          for (let i = 0; i < cleanHullVerts.length; i++) {
            const j = (i + 1) % cleanHullVerts.length;
            area += cleanHullVerts[i][0] * cleanHullVerts[j][1];
            area -= cleanHullVerts[j][0] * cleanHullVerts[i][1];
          }
          if (area < 0) cleanHullVerts.reverse();

          const convexShape = new p2.Convex({ vertices: cleanHullVerts });
          convexShape.material = window.defaultShapeMaterial;
          body.addShape(convexShape);
        }

        world.addBody(body);
        dynamicBodies.push(body);
      }

      // --- Renderöinti ---

      function drawShape(shape, body) {
        ctx.save();
        // 1. Siirry kappaleen keskipisteeseen
        ctx.translate(mToPx(body.position[0]), mToPx(body.position[1]));
        ctx.rotate(body.angle);

        ctx.lineWidth = 2;

        if (shape instanceof p2.Box) {
          const w = mToPx(shape.width);
          const h = mToPx(shape.height);
          ctx.fillStyle = "#1e293b";
          ctx.fillRect(-w / 2, -h / 2, w, h);
          ctx.beginPath();
          ctx.moveTo(-w / 2, h / 2);
          ctx.lineTo(w / 2, h / 2);
          ctx.strokeStyle = "#3b82f6";
          ctx.stroke();
        } else if (shape instanceof p2.Convex) {
          // TÄRKEÄ KORJAUS:
          // Kun muoto on pilkottu (decomp), osilla on omat suhteelliset sijainnit (position) ja kulmat (angle).
          // Meidän täytyy siirtää piirtoa näiden mukaan suhteessa bodyn keskipisteeseen.
          ctx.save();
          if (shape.position) {
            ctx.translate(mToPx(shape.position[0]), mToPx(shape.position[1]));
          }
          if (shape.angle) {
            ctx.rotate(shape.angle);
          }

          const verts = shape.vertices;
          ctx.beginPath();
          if (verts.length > 0) {
            ctx.moveTo(mToPx(verts[0][0]), mToPx(verts[0][1]));
            for (let i = 1; i < verts.length; i++) {
              ctx.lineTo(mToPx(verts[i][0]), mToPx(verts[i][1]));
            }
          }
          ctx.closePath();
          ctx.fillStyle = "#facc15";
          ctx.strokeStyle = "#a16207";
          ctx.fill();
          ctx.stroke();

          ctx.restore(); // Palauta shape-kohtainen siirros
        }

        ctx.restore(); // Palauta body-kohtainen siirros
      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);

        world.bodies.forEach((body) => {
          body.shapes.forEach((shape) => drawShape(shape, body));
        });
        ctx.restore();

        if (isDrawing && drawPath.length > 0) {
          ctx.lineCap = "round";
          ctx.lineJoin = "round";

          ctx.beginPath();
          ctx.moveTo(drawPath[0].x, drawPath[0].y);
          for (let i = 1; i < drawPath.length; i++)
            ctx.lineTo(drawPath[i].x, drawPath[i].y);
          ctx.strokeStyle = "#ef4444";
          ctx.lineWidth = 4;
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(drawPath[0].x, drawPath[0].y);
          for (let i = 1; i < drawPath.length; i++)
            ctx.lineTo(drawPath[i].x, drawPath[i].y);
          ctx.closePath();
          ctx.fillStyle = "rgba(250, 204, 21, 0.2)";
          ctx.fill();
        }
      }

      let lastTime = 0;
      const timeStep = 1 / 60;

      function animate(time) {
        requestAnimationFrame(animate);
        const deltaTime = (time - lastTime) / 1000;
        lastTime = time;
        world.step(timeStep, deltaTime, 10);
        render();
      }

      // --- POINTER EVENTS ---

      function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }

      function handlePointerDown(e) {
        if (e.target !== canvas) return;
        e.preventDefault();
        isDrawing = true;
        drawPath = [getPos(e)];
        canvas.setPointerCapture(e.pointerId);
        SoundManager.init(); // Käynnistä AudioContext user gesturella
      }

      function handlePointerMove(e) {
        if (!isDrawing) return;
        e.preventDefault();
        const pos = getPos(e);
        const last = drawPath[drawPath.length - 1];
        if (Math.hypot(pos.x - last.x, pos.y - last.y) > 2) {
          drawPath.push(pos);
        }
      }

      function handlePointerUp(e) {
        if (!isDrawing) return;
        isDrawing = false;
        canvas.releasePointerCapture(e.pointerId);
        createBodyFromPath(drawPath);
        drawPath = [];
        SoundManager.playDrawComplete();
      }

      function resetSimulation() {
        dynamicBodies.forEach((b) => world.removeBody(b));
        dynamicBodies = [];
      }

      // --- Gravity Control ---

      function handleOrientation(event) {
        if (!gravityEnabled) return;

        // Gamma: left to right motion (-90 to 90) -> X gravity
        // Beta: front to back motion (-180 to 180) -> Y gravity

        let x = event.gamma;
        let y = event.beta;

        // Rajoitetaan arvoja ja poistetaan kohinaa
        if (!x) x = 0;
        if (!y) y = 0;

        // Portrait mode mapping
        // Puhelin pystyasennossa (beta ~90) -> gravity Y = -9.82
        // Puhelin vaaka-asennossa (gamma) -> gravity X

        // Yksinkertainen mappaus:
        // Beta 90 = pysty -> Y gravity negatiivinen (alas)
        // Beta 0 = makaa pöydällä -> Y gravity 0

        // Säädetään herkkyyttä
        const gx = (x / 45) * 10;
        const gy = ((y - 45) / 45) * 10 - 5; // Offset 45 astetta "mukavaan" katselukulmaan

        // Tai yksinkertaisemmin suoraan painovoimavektorin kääntö
        // Mutta p2.js gravity on globaali [x, y]

        // Otetaan käyttöön intuitiivisempi malli:
        // Laite pystyssä tasolla: painovoima alas.
        // Kallistus oikealle -> painovoima oikealle.

        const gravityScale = 20;
        const radX = (x * Math.PI) / 180;
        const radY = (y * Math.PI) / 180;

        world.gravity[0] = Math.sin(radX) * gravityScale;
        world.gravity[1] = -Math.sin(radY) * gravityScale; // Negatiivinen koska Y ylös on positiivinen p2:ssa?
        // Default p2 gravity on [0, -9.82], eli Y-akseli osoittaa ylös
        // Joten kun puhelin on pystyssä (beta=90), painovoiman pitää olla negatiivinen Y.

        // Beta ~90 -> sin(90) = 1 -> haluamme -g. Eli -sin(beta).
        // Mutta "nolla" asento on usein ~45 astetta kädessä.
        // Käytetään suoraa mappia:

        /*
            Device Orientation Coordinates:
            x (gamma): -90 (left) to 90 (right)
            y (beta): -180 to 180 (front/back)
          */

        // X-akseli: gamma
        world.gravity[0] = (x / 45) * 9.82;

        // Y-akseli: beta.
        // Kun beta = 90 (pystyssä), gravity Y = -9.82
        // Kun beta = 0 (makaa), gravity Y = 0 (tai -9.82 Z-akselilla, joka ei vaikuta 2D)
        // Tehdään niin että kun puhelin on pystyssä, painovoima vetää näytön "alas".
        // Näytön "alas" on canvasissa -Y.

        // Korjataan logiikkaa kokeilemalla:
        // Beta kasvaa kun puhelimen yläosa nousee.
        // Haluamme että painovoima vetää alas (-Y) kun puhelin on pystyssä.
        world.gravity[1] = -(y / 90) * 9.82 * 1.5;

        // Rajoitetaan
        world.gravity[0] = Math.max(
          -MAX_GRAVITY,
          Math.min(MAX_GRAVITY, world.gravity[0])
        );
        world.gravity[1] = Math.max(
          -MAX_GRAVITY,
          Math.min(MAX_GRAVITY, world.gravity[1])
        );
      }

      function toggleGravity() {
        const btn = document.getElementById("gravityButton");

        if (!gravityEnabled) {
          // Enable
          if (
            typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function"
          ) {
            // iOS 13+
            DeviceOrientationEvent.requestPermission()
              .then((response) => {
                if (response === "granted") {
                  gravityEnabled = true;
                  window.addEventListener(
                    "deviceorientation",
                    handleOrientation
                  );
                  activateGravityUI(true);
                } else {
                  alert("Lupa evätty");
                }
              })
              .catch(console.error);
          } else {
            // Android / Old iOS / Desktop
            gravityEnabled = true;
            window.addEventListener("deviceorientation", handleOrientation);
            activateGravityUI(true);

            // Testaus/Desktop fallback "hiiri-painovoimalle" jos halutaan? Ei nyt.
            if (!window.DeviceOrientationEvent) {
              alert("Laitteesi ei tue kallistusta tai selain ei salli sitä.");
              // Palautetaan tila jotta ei jää jumiin
              gravityEnabled = false;
            }
          }
        } else {
          // Disable
          gravityEnabled = false;
          window.removeEventListener("deviceorientation", handleOrientation);
          world.gravity = [0, -9.82]; // Reset gravity
          activateGravityUI(false);
        }
      }

      function activateGravityUI(active) {
        const btn = document.getElementById("gravityButton");
        if (active) {
          btn.classList.replace("bg-slate-600/80", "bg-green-600/80");
          btn.classList.replace("hover:bg-slate-600", "hover:bg-green-600");
        } else {
          btn.classList.replace("bg-green-600/80", "bg-slate-600/80");
          btn.classList.replace("hover:bg-green-600", "hover:bg-slate-600");
        }
      }

      window.onload = function () {
        initCanvas();
        initPhysicsWorld();

        canvas.addEventListener("pointerdown", handlePointerDown);
        canvas.addEventListener("pointermove", handlePointerMove);
        canvas.addEventListener("pointerup", handlePointerUp);
        canvas.addEventListener("pointercancel", handlePointerUp);

        document
          .getElementById("resetButton")
          .addEventListener("click", resetSimulation);

        document
          .getElementById("gravityButton")
          .addEventListener("click", toggleGravity);

        document
          .getElementById("muteButton")
          .addEventListener("click", function () {
            const isMuted = SoundManager.toggleMute();
            const iconOn = document.getElementById("iconSoundOn");
            const iconOff = document.getElementById("iconSoundOff");
            const btn = document.getElementById("muteButton");

            if (isMuted) {
              iconOn.classList.add("hidden");
              iconOff.classList.remove("hidden");
              btn.classList.replace("bg-slate-600/80", "bg-red-500/80"); // Visuaalinen indikaattori
              btn.classList.replace("hover:bg-slate-600", "hover:bg-red-500");
            } else {
              iconOn.classList.remove("hidden");
              iconOff.classList.add("hidden");
              btn.classList.replace("bg-red-500/80", "bg-slate-600/80");
              btn.classList.replace("hover:bg-red-500", "hover:bg-slate-600");
            }
          });

        window.addEventListener("resize", updateCanvasSize);

        requestAnimationFrame(animate);
      };
    </script>
  </body>
</html>
